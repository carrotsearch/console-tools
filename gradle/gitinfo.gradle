
//
// git info
//

import org.eclipse.jgit.storage.file.*
import org.eclipse.jgit.api.*;

buildscript {
  repositories {
    mavenCentral()
  }

  dependencies {
    classpath 'org.eclipse.jgit:org.eclipse.jgit:5.3.0.201903130848-r'
    classpath 'commons-codec:commons-codec:1.6'
  }
}

/** Return the current checkout's status. */
def gitStatus(dir) {
  def status = [
    abbrRev: "[unset]",
    fullRev: "[unset]",
    clean:   false,
    branch:  "[unset]",
    id:      "[unset]"
  ]

  try {
    def repo = new FileRepositoryBuilder()
      .findGitDir(file(dir))
      .build()
    def git = new Git(repo);
    def head = repo.findRef("HEAD")

    def st = git.status().call()
    def commit = head.getObjectId()
    status.fullRev = commit.name()
    status.abbrRev = commit.abbreviate(8).name()
    status.clean = st.clean
    status.branch = repo.branch

    status.id = status.branch + "/" + status.abbrRev
    if (!status.clean) {
      status.id += '-dirty'

      logger.warn("Git status indicates dirty checkout (run with --info for verbose git status)")
      logger.info("Git status is: added={}, changed={}, conflicting={}, ignored={}, missing={}, modified={}, removed={}, untracked={}, untrackedFolders={}",
        st.added, 
        st.changed,
        st.conflicting,
        st.ignoredNotInIndex,
        st.missing,
        st.modified,
        st.removed,
        st.untracked,
        st.untrackedFolders);
    }
  } catch (Exception e) {
    throw e // Break the build if not under a repo.
  }

  return status
}

ext.gitStatus = gitStatus(".")
